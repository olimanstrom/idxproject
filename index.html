<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Webcam Recording</title>
  <link href="styles.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
  <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>

  <style>
    /* Your styles here */
  </style>
</head>
<body>
  <h1 id="title" class="text-3xl font-bold underline">Body Segmentation</h1>

  <button id="startRecording">Start Recording</button>
  <button id="stopRecording">Stop Recording</button>
  <a id="downloadLink" style="display:none;">Download</a>

  <button id="changeScript">Change Script</button>

  <script>
    let bodySegmentation;
    let video;
    let segmentation;
    let currentMode = 'betterPerformance';  // Track the current mode

    let optionsBetterPerformance = {
      maskType: "parts",  // Configuration for better performance
      //flipped: true,  // Flip the video horizontally
    };

    let optionsFullBody = {
      maskType: "parts",  // Configuration for full body
      //flipped: true,  // Flip the video horizontally
    };

    // Function to reset and start the segmentation model
    function startSegmentation(mode) {
      // Clear previous segmentation results
      segmentation = null;

      let options = mode === 'betterPerformance' ? optionsBetterPerformance : optionsFullBody;

      // Initialize new segmentation model
      bodySegmentation = ml5.bodySegmentation('BodyPix', options, () => {
        console.log(`Started ${mode} segmentation`);
        bodySegmentation.detectStart(video, gotResults);
      });
    }

    function setup() {
      let canvas = createCanvas(1280, 480);  // Main canvas
      canvas.id('canvas');  // Assign an id to the canvas for capturing

      // Create the video
      video = createCapture(VIDEO);
      video.size(640, 480);
      video.hide();

      // Start segmentation with the initial mode
      startSegmentation(currentMode);
    }

    function draw() {
      background(255);

      // Draw the segmentation result
      if (segmentation) {
        let coloredMask = createColoredMask(segmentation);
        let xPosition = (width - 640) / 2;  // Centering the video horizontally
        image(coloredMask, xPosition, 0, 640, 480);  // Display the result centered
      }
    }

    // Callback function for body segmentation results
    function gotResults(result) {
      segmentation = result;
    }

    // Toggle between full body and better performance segmentation
    document.getElementById('changeScript').addEventListener('click', function () {
      currentMode = currentMode === 'betterPerformance' ? 'fullBody' : 'betterPerformance';
      console.log(`Switching to ${currentMode} mode`);

      // Restart the segmentation model with the new mode
      startSegmentation(currentMode);
    });

    function createColoredMask(segmentation) {
      let imgData = segmentation.imageData;
      let coloredMask = createImage(imgData.width, imgData.height);
      coloredMask.loadPixels();

      // Define unwanted part IDs to skip, only used in betterPerformance mode
      let unwantedPartIds = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

      for (let y = 0; y < imgData.height; y++) {
        for (let x = 0; x < imgData.width; x++) {
          let index = (x + y * imgData.width) * 4;
          let partId = imgData.data[index];

          let r, g, b;

          // Mode-specific processing
          if (currentMode === 'betterPerformance') {
            // Skip unwanted part IDs in betterPerformance mode
            if (unwantedPartIds.includes(partId)) {
              r = 255; g = 255; b = 255; // White (or transparent if needed)
            } else {
              // Paint selected parts
              switch (partId) {
                case 10: r = 0; g = 0; b = 255; break; // Blue for left_hand
                case 11: r = 0; g = 0; b = 255; break; // Blue for right_hand
                case 14: r = 128; g = 128; b = 128; break; // Gray for left_upper_leg_front
                case 15: r = 128; g = 128; b = 128; break; // Gray for left_upper_leg_back
                case 16: r = 128; g = 128; b = 128; break; // Gray for right_upper_leg_front
                case 17: r = 128; g = 128; b = 128; break; // Gray for right_upper_leg_back
                case 18: r = 128; g = 128; b = 128; break; // Gray for left_lower_leg_front
                case 19: r = 128; g = 128; b = 128; break; // Gray for left_lower_leg_back
                case 20: r = 128; g = 128; b = 128; break; // Gray for right_lower_leg_front
                case 21: r = 128; g = 128; b = 128; break; // Gray for right_lower_leg_back
                case 22: r = 0; g = 0; b = 255; break; // Blue for left_foot
                case 23: r = 0; g = 0; b = 255; break; // Blue for right_foot
                default: r = 255; g = 255; b = 255; break; // White for other parts in betterPerformance mode
              }
            }
          } else {
            // Full body mode: Render all parts, no skipping
            switch (partId) {
              case 0: r = 255; g = 224; b = 189; break; // Skin tone for face
              case 1: r = 255; g = 224; b = 189; break; // Skin tone for ears
              case 2: r = 255; g = 224; b = 189; break; // Skin tone for neck
              case 3: r = 255; g = 224; b = 189; break; // Skin tone for forehead
              case 10: r = 0; g = 0; b = 255; break; // Blue for left_hand
              case 11: r = 0; g = 0; b = 255; break; // Blue for right_hand
              case 12: r = 128; g = 128; b = 128; break; // Gray for torso front
              case 13: r = 128; g = 128; b = 128; break; // Gray for torso back
              case 14: r = 128; g = 128; b = 128; break; // Gray for left_upper_leg_front
              case 15: r = 128; g = 128; b = 128; break; // Gray for left_upper_leg_back
              case 16: r = 128; g = 128; b = 128; break; // Gray for right_upper_leg_front
              case 17: r = 128; g = 128; b = 128; break; // Gray for right_upper_leg_back
              case 18: r = 128; g = 128; b = 128; break; // Gray for left_lower_leg_front
              case 19: r = 128; g = 128; b = 128; break; // Gray for left_lower_leg_back
              case 20: r = 128; g = 128; b = 128; break; // Gray for right_lower_leg_front
              case 21: r = 128; g = 128; b = 128; break; // Gray for right_lower_leg_back
              case 22: r = 0; g = 0; b = 255; break; // Blue for left_foot
              case 23: r = 0; g = 0; b = 255; break; // Blue for right_foot
              default: r = 128; g = 128; b = 128; break; // Gray for unspecified parts
            }
          }

          // Apply color to the pixel
          coloredMask.pixels[index] = r;
          coloredMask.pixels[index + 1] = g;
          coloredMask.pixels[index + 2] = b;
          coloredMask.pixels[index + 3] = imgData.data[index + 3]; // Keep the original alpha
        }
      }
      coloredMask.updatePixels();
      return coloredMask;
    }



    // Start p5.js
    window.setup = setup;
    window.draw = draw;
  </script>
</body>
</html>
